<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kauffman Bracket Explorer — An Introduction</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap');

  :root {
    --bg: #0c0e13;
    --surface: #14171e;
    --surface2: #1a1e28;
    --surface3: #1f2433;
    --border: #2a2f3d;
    --text: #d4d8e4;
    --text-dim: #6b7394;
    --text-bright: #eef0f6;
    --accent-a: #5b9bd5;
    --accent-b: #d4845a;
    --accent-loop: #7bc77b;
    --accent-poly: #c4a0e8;
    --highlight: #f0d060;
    --negative: #e06070;
    --positive: #60c080;
    --link: #8bb8e0;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Crimson Pro', Georgia, serif;
    min-height: 100vh;
    overflow-x: hidden;
    font-size: 17px;
    line-height: 1.7;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(91,155,213,0.03) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(196,160,232,0.03) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 860px;
    margin: 0 auto;
    padding: 2.5rem 1.5rem 4rem;
  }

  /* ---- HEADER ---- */
  header {
    text-align: center;
    margin-bottom: 3rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border);
  }

  header h1 {
    font-weight: 300;
    font-size: 2.4rem;
    letter-spacing: 0.03em;
    color: var(--text-bright);
    margin-bottom: 0.3rem;
  }

  header h1 em {
    color: var(--accent-poly);
    font-style: italic;
  }

  header .subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  /* ---- PROSE SECTIONS ---- */
  .prose {
    margin-bottom: 2.5rem;
  }

  .prose h2 {
    font-weight: 400;
    font-size: 1.5rem;
    color: var(--text-bright);
    margin-bottom: 0.75rem;
    letter-spacing: 0.01em;
  }

  .prose h2 .num {
    color: var(--accent-poly);
    font-style: italic;
    margin-right: 0.3rem;
  }

  .prose h3 {
    font-weight: 500;
    font-size: 1.1rem;
    color: var(--text-bright);
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
  }

  .prose p {
    margin-bottom: 1rem;
    color: var(--text);
  }

  .prose p.dim {
    color: var(--text-dim);
    font-style: italic;
  }

  .key-term {
    color: var(--accent-poly);
    font-weight: 500;
  }

  .color-a { color: var(--accent-a); }
  .color-b { color: var(--accent-b); }
  .color-loop { color: var(--accent-loop); }

  /* ---- FIGURES (inline diagrams) ---- */
  .figure {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1.25rem;
    margin: 1.25rem 0 1.5rem;
    text-align: center;
  }

  .figure canvas {
    display: block;
    margin: 0 auto;
  }

  .figure-caption {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    color: var(--text-dim);
    margin-top: 0.75rem;
    letter-spacing: 0.03em;
    line-height: 1.5;
  }

  /* ---- FORMULA BOXES ---- */
  .formula-box {
    background: var(--surface);
    border-left: 3px solid var(--accent-poly);
    padding: 1rem 1.25rem;
    margin: 1.25rem 0 1.5rem;
    font-family: 'Crimson Pro', serif;
    font-size: 1.15rem;
    text-align: center;
    line-height: 1.9;
  }

  .formula-box .var-a { color: var(--accent-poly); font-style: italic; }
  .formula-box sup { font-size: 0.7em; }
  .formula-box .label {
    display: block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.62rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.5rem;
    text-align: left;
  }

  /* ---- STEP CALLOUTS ---- */
  .step-box {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1rem 1.25rem;
    margin: 1rem 0;
  }

  .step-box .step-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--accent-poly);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.3rem;
  }

  /* ---- SEPARATOR ---- */
  .sep {
    border: none;
    border-top: 1px solid var(--border);
    margin: 3rem 0;
  }

  /* ---- INTERACTIVE TOOL SECTION ---- */
  .tool-header {
    text-align: center;
    margin-bottom: 1.5rem;
  }

  .tool-header h2 {
    font-weight: 300;
    font-size: 1.6rem;
    color: var(--text-bright);
    margin-bottom: 0.3rem;
  }

  .tool-header .subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
  }

  /* Knot selector */
  .knot-selector {
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }

  .knot-btn {
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    padding: 0.55rem 1.3rem;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.25s ease;
    letter-spacing: 0.02em;
  }

  .knot-btn:hover {
    border-color: var(--accent-poly);
    color: var(--text);
  }

  .knot-btn.active {
    background: var(--surface2);
    border-color: var(--accent-poly);
    color: var(--accent-poly);
    box-shadow: 0 0 12px rgba(196,160,232,0.1);
  }

  .knot-desc {
    text-align: center;
    font-size: 0.95rem;
    color: var(--text-dim);
    margin-bottom: 1.5rem;
    font-style: italic;
    min-height: 2.5em;
  }

  .instructions {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--text-dim);
    text-align: center;
    margin-bottom: 1.25rem;
    letter-spacing: 0.04em;
  }

  .instructions kbd {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 1px 5px;
    border-radius: 2px;
    font-size: 0.6rem;
  }

  /* Main layout */
  .main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
  }

  @media (max-width: 860px) {
    .main-grid { grid-template-columns: 1fr; }
  }

  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1.25rem;
  }

  .panel-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-dim);
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
  }

  /* Crossing diagram */
  .crossing-diagram {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
    min-height: 120px;
    align-items: center;
  }

  .crossing-box {
    position: relative;
    width: 100px;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .crossing-box:hover { transform: scale(1.08); }

  .crossing-box canvas { width: 100%; height: 100px; }

  .crossing-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    text-align: center;
    color: var(--text-dim);
    margin-top: 4px;
    letter-spacing: 0.05em;
  }

  .smoothing-type {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    text-align: center;
    margin-top: 2px;
    font-weight: 500;
    transition: color 0.2s;
  }

  .smoothing-type.type-a { color: var(--accent-a); }
  .smoothing-type.type-b { color: var(--accent-b); }

  /* Loop canvas */
  .loop-canvas-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
  }

  #loopCanvas { border-radius: 3px; }

  /* State table */
  .state-table-wrap {
    max-height: 420px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }

  .state-table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
  }

  .state-table th {
    position: sticky;
    top: 0;
    background: var(--surface);
    color: var(--text-dim);
    font-weight: 400;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-size: 0.6rem;
    padding: 0.5rem 0.4rem;
    border-bottom: 1px solid var(--border);
    text-align: left;
  }

  .state-table td {
    padding: 0.4rem 0.4rem;
    border-bottom: 1px solid rgba(42,47,61,0.5);
    vertical-align: middle;
  }

  .state-table tr { transition: background 0.15s; cursor: pointer; }
  .state-table tr:hover { background: rgba(196,160,232,0.04); }
  .state-table tr.active-state { background: rgba(196,160,232,0.08); }
  .state-table tr.active-state td { color: var(--accent-poly); }

  .state-bits { display: inline-flex; gap: 2px; }

  .bit {
    display: inline-block;
    width: 16px; height: 16px;
    line-height: 16px;
    text-align: center;
    border-radius: 2px;
    font-size: 0.6rem;
    font-weight: 500;
  }

  .bit-a { background: rgba(91,155,213,0.15); color: var(--accent-a); }
  .bit-b { background: rgba(212,132,90,0.15); color: var(--accent-b); }

  .loops-badge {
    display: inline-block;
    background: rgba(123,199,123,0.12);
    color: var(--accent-loop);
    padding: 1px 6px;
    border-radius: 2px;
  }

  /* Result polynomial */
  .result-panel { grid-column: 1 / -1; }

  .polynomial-display {
    font-family: 'Crimson Pro', serif;
    font-size: 1.3rem;
    text-align: center;
    padding: 0.75rem 1rem;
    line-height: 1.8;
    letter-spacing: 0.01em;
    word-break: break-word;
  }

  .polynomial-display .coeff-pos { color: var(--positive); }
  .polynomial-display .coeff-neg { color: var(--negative); }
  .polynomial-display .var-a { color: var(--accent-poly); font-style: italic; }
  .polynomial-display .sup { font-size: 0.8em; vertical-align: super; }

  .info-row {
    display: flex;
    gap: 2rem;
    justify-content: center;
    margin-top: 0.5rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    flex-wrap: wrap;
  }

  .info-row span { display: inline-flex; align-items: center; gap: 0.3rem; }
  .info-row .dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; }
  .dot-a { background: var(--accent-a); }
  .dot-b { background: var(--accent-b); }
  .dot-loop { background: var(--accent-loop); }
  .dot-poly { background: var(--accent-poly); }

  /* Accumulation */
  .accum-controls {
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    align-items: center;
    margin: 1rem 0 0.5rem;
    flex-wrap: wrap;
  }

  .accum-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    padding: 0.4rem 1rem;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.2s;
    letter-spacing: 0.03em;
  }

  .accum-btn:hover { border-color: var(--accent-poly); color: var(--text); }
  .accum-btn.active-play { border-color: var(--accent-loop); color: var(--accent-loop); }

  .accum-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--text-dim);
  }

  .running-sum {
    font-family: 'Crimson Pro', serif;
    font-size: 1.1rem;
    text-align: center;
    padding: 0.5rem;
    min-height: 2em;
    color: var(--highlight);
  }

  .running-sum .coeff-pos { color: var(--positive); }
  .running-sum .coeff-neg { color: var(--negative); }
  .running-sum .var-a { color: var(--accent-poly); font-style: italic; }
  .running-sum .sup { font-size: 0.8em; vertical-align: super; }

  /* Animations */
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .panel { animation: fadeIn 0.4s ease both; }
  .panel:nth-child(2) { animation-delay: 0.1s; }

  /* TOC sidebar hint */
  .toc {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1rem 1.25rem;
    margin-bottom: 2.5rem;
  }

  .toc-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.62rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.6rem;
  }

  .toc a {
    display: block;
    color: var(--text-dim);
    text-decoration: none;
    font-size: 0.92rem;
    padding: 0.2rem 0;
    transition: color 0.2s;
  }

  .toc a:hover { color: var(--accent-poly); }
  .toc a .num { color: var(--accent-poly); font-style: italic; margin-right: 0.4rem; }
</style>
</head>
<body>
<div class="container">

  <header>
    <h1>The Kauffman <em>Bracket</em></h1>
    <div class="subtitle">An interactive introduction to knot invariants</div>
  </header>

  <!-- TABLE OF CONTENTS -->
  <div class="toc">
    <div class="toc-title">Contents</div>
    <a href="#sec-what"><span class="num">1.</span> What is a knot (mathematically)?</a>
    <a href="#sec-problem"><span class="num">2.</span> The central problem: telling knots apart</a>
    <a href="#sec-crossings"><span class="num">3.</span> Crossings and diagrams</a>
    <a href="#sec-smoothing"><span class="num">4.</span> Smoothing a crossing</a>
    <a href="#sec-statesum"><span class="num">5.</span> The state sum: counting loops</a>
    <a href="#sec-bracket"><span class="num">6.</span> The Kauffman bracket formula</a>
    <a href="#sec-code"><span class="num">7.</span> What the C code does</a>
    <a href="#sec-tool"><span class="num">8.</span> Interactive explorer</a>
  </div>

  <!-- ====== SECTION 1 ====== -->
  <div class="prose" id="sec-what">
    <h2><span class="num">1.</span> What is a knot (mathematically)?</h2>

    <p>Take a piece of string. Tie it in a knot. Now glue the two ends together so it forms a closed loop. That closed, knotted loop — floating in three-dimensional space — is what mathematicians call a <span class="key-term">knot</span>.</p>

    <p>Why a closed loop? If the ends are free, you can always just slide the knot off the end of the string — every knot unties. By joining the ends, the knottedness is <em>trapped</em>. There is no way to cheat. The only way to change the knot is to deform the loop smoothly through space — stretching, bending, rearranging — but never cutting it or passing it through itself. This makes the question "is this knot really knotted?" a precise mathematical one rather than a vague physical one.</p>

    <p>The simplest knot is just a plain circle with no crossings at all — the <span class="key-term">unknot</span>. (Yes, a plain circle counts as a "knot" in this field — it is the trivial case, analogous to zero being a number.) The simplest <em>actual</em> knot is the <span class="key-term">trefoil</span>, which is what you get if you make the simplest possible overhand knot and then join the ends. After that, there is a whole zoo: the figure-eight knot, the cinquefoil, torus knots, and so on — catalogued meticulously since the 1800s.</p>

    <p>A <span class="key-term">link</span> is the same idea but with two or more loops tangled together — like chain links. The <span class="key-term">Hopf link</span> is the simplest: just two circles linked once through each other.</p>

    <div class="figure">
      <canvas id="figKnots" width="700" height="180"></canvas>
      <div class="figure-caption">Left: the unknot (plain circle). Center: the trefoil knot (three crossings). Right: the Hopf link (two linked circles).</div>
    </div>
  </div>

  <!-- ====== SECTION 2 ====== -->
  <div class="prose" id="sec-problem">
    <h2><span class="num">2.</span> The central problem: telling knots apart</h2>

    <p>Why would you want to know whether two knots are "the same"? Consider: if someone hands you a horribly tangled loop of string, is there <em>any</em> sequence of moves that will untangle it into a plain circle — or is the knottedness fundamental, impossible to remove without cutting? This is not an idle question. It arises naturally in molecular biology (DNA strands form knots whose topology affects how enzymes can act on them), in chemistry (molecular knots have different properties from their unknotted counterparts), and in physics (quantum field theories and statistical mechanics both involve knot-like structures). But even purely as mathematics, it is a deep and beautiful problem.</p>

    <p>Here is the fundamental difficulty: if someone hands you two tangled loops of string, how do you know whether one can be deformed into the other without cutting? A trefoil <em>looks</em> different from a figure-eight knot, but can you <em>prove</em> they are truly distinct, or might one just be a rearranged version of the other? Worse, the same knot can look wildly different depending on how you lay it on a table. You can add unnecessary extra crossings by twisting the string, or rearrange crossings by sliding strands over each other. Two diagrams that look completely different might secretly be the same knot.</p>

    <p>You cannot just count crossings — the same knot can be drawn with more or fewer crossings depending on how you arrange it on the page. What you need is an <span class="key-term">invariant</span>: some quantity you can compute from a knot diagram that is guaranteed to give the <em>same</em> answer no matter how you draw that particular knot, but (hopefully) gives <em>different</em> answers for genuinely different knots.</p>

    <p>Think of it like a fingerprint. If two people have different fingerprints, you know they are different people. An invariant works the same way for knots: if two knots have different invariants, they are definitely different knots. (The reverse is not guaranteed — just as two different people <em>could</em> theoretically have very similar fingerprints, two different knots could have the same invariant. A stronger invariant is one that distinguishes more knots.)</p>

    <p>The <span class="key-term">Kauffman bracket</span> (discovered by Louis Kauffman in 1987) is exactly such an invariant. It assigns a polynomial — an algebraic expression in a variable <em>A</em> — to each knot. If two knots have different brackets, they are definitely different knots. It is one of the most elegant constructions in all of mathematics, and it can be computed by a beautifully simple procedure.</p>
  </div>

  <!-- ====== SECTION 3 ====== -->
  <div class="prose" id="sec-crossings">
    <h2><span class="num">3.</span> Crossings and diagrams</h2>

    <p>A knot lives in three-dimensional space, but that is hard to work with on paper or in a computer. So we <em>project</em> it — imagine holding the knot above a table and looking straight down. The shadow it casts is a flat curve that crosses itself wherever one strand passes over another. This flat picture is a <span class="key-term">knot diagram</span>.</p>

    <p>At each place the curve crosses itself, we get a <span class="key-term">crossing</span>. We draw the under-strand with a small gap to show it passes behind — this is the one piece of 3D information we preserve in the flat picture. A knot diagram with its crossing information is enough to reconstruct the full 3D knot (up to the kind of smooth deformations we allow).</p>

    <p>Each crossing involves four <span class="key-term">arcs</span> — the four strands leading into and out of the crossing point. (An "arc" is the portion of the knot between two adjacent crossings.) We label these arcs with numbers and list them in counter-clockwise order starting from the incoming under-strand. This is called <span class="key-term">PD (planar diagram) notation</span> — it is the standard way to encode a knot as pure data that a computer can work with. The entire topology of the knot is captured by this list of arc labels at each crossing.</p>

    <div class="figure">
      <canvas id="figCrossing" width="500" height="200"></canvas>
      <div class="figure-caption">A single crossing with four arcs labeled [a, b, c, d] in PD order (counter-clockwise from incoming under-strand). The under-strand enters at arc a and exits at arc c. The over-strand enters at arc d and exits at arc b.</div>
    </div>

    <p>For example, the trefoil has 3 crossings and 6 arcs. Its PD notation is:</p>

    <div class="formula-box">
      <span class="label">Trefoil — PD notation</span>
      X[0,4,1,3] &nbsp;&nbsp; X[2,0,3,5] &nbsp;&nbsp; X[4,2,5,1]
    </div>

    <p>Each bracket lists the four arc numbers at that crossing. Notice that every arc number appears exactly twice across all the crossings — once where it enters a crossing and once where it leaves another. This is how the crossings are "wired together" into a continuous loop. The figure-eight knot has 4 crossings and 8 arcs; the Hopf link has 2 crossings and 4 arcs.</p>
  </div>

  <!-- ====== SECTION 4 ====== -->
  <div class="prose" id="sec-smoothing">
    <h2><span class="num">4.</span> Smoothing a crossing</h2>

    <p>The key operation in computing the Kauffman bracket is <span class="key-term">smoothing</span>. The basic idea is: what if we could "undo" a crossing? At each crossing, instead of having two strands cross over each other, we <em>reconnect</em> the strands so they no longer cross at all — they just curve past each other. This eliminates the crossing entirely.</p>

    <p>But here is the crucial point: there are <em>two different ways</em> to reconnect the strands. Imagine you are standing at the crossing looking at the four arcs coming in. You can pair them up two ways — and each way produces a different reconnection:</p>

    <div class="step-box">
      <div class="step-num"><span class="color-a">A-smoothing</span></div>
      <p>Connect arc 0 with arc 3, and arc 1 with arc 2. Visually, this joins the strands into two curves that "pass by" each other horizontally.</p>
    </div>

    <div class="step-box">
      <div class="step-num"><span class="color-b">B-smoothing</span></div>
      <p>Connect arc 0 with arc 1, and arc 2 with arc 3. This joins the strands the other way — they "bounce back" on themselves vertically.</p>
    </div>

    <div class="figure">
      <canvas id="figSmoothing" width="600" height="180"></canvas>
      <div class="figure-caption">Left: the original crossing. Center: <span style="color:#5b9bd5">A-smoothing</span> (pairs 0–3 and 1–2). Right: <span style="color:#d4845a">B-smoothing</span> (pairs 0–1 and 2–3).</div>
    </div>

    <p>Each smoothing choice eliminates one crossing. If we choose a smoothing for <em>every</em> crossing in the knot, we eliminate <em>all</em> the crossings, and the knot dissolves into a collection of simple, non-crossing <span class="key-term">loops</span> — plain circles sitting on the page with no crossings at all.</p>

    <p>This is the key insight: a knot is complicated because of its crossings. Smoothing removes that complexity entirely, leaving behind the simplest possible topological objects — circles. The price we pay is that there were <em>choices</em> involved (A or B at each crossing), and different choices produce different numbers of circles. The Kauffman bracket is a way of bookkeeping all those choices and their consequences into a single algebraic expression.</p>
  </div>

  <!-- ====== SECTION 5 ====== -->
  <div class="prose" id="sec-statesum">
    <h2><span class="num">5.</span> The state sum: counting loops</h2>

    <p>A <span class="key-term">state</span> is a specific choice of smoothing (A or B) for every crossing. A knot with <em>n</em> crossings has 2<sup>n</sup> possible states — every combination of A and B across all crossings. (This is the same as counting in binary: for 3 crossings, you get AAA, AAB, ABA, ABB, BAA, BAB, BBA, BBB — eight states total.)</p>

    <p>For each state, once all crossings are smoothed away, we are left with some number of simple closed loops. We count them. This loop count is the crucial piece of information from each state. Intuitively, more loops means the smoothing "separated" the knot into more pieces, while fewer loops means the strands stayed more connected.</p>

    <p>For instance, the trefoil has 3 crossings, so 2³ = 8 states. Some states yield 1 loop, some yield 2, and some yield 3. Different knots produce different <em>patterns</em> of loop counts across their states — and this is ultimately what makes the bracket different for different knots.</p>

    <p>The explorer below lets you see this for yourself — click on the crossings to change the smoothing and watch the loop count change. Try to find the state that produces the most loops, and the one that produces the fewest.</p>
  </div>

  <!-- ====== SECTION 6 ====== -->
  <div class="prose" id="sec-bracket">
    <h2><span class="num">6.</span> The Kauffman bracket formula</h2>

    <p>Now we assemble the bracket. The idea is to sum a contribution from <em>every</em> state — all 2<sup>n</sup> of them. We do not pick a single "best" smoothing; we consider <em>all possible</em> smoothings simultaneously, weighted by algebraic factors that keep track of which choices were made. This "consider every possibility and sum them up" approach is called a <span class="key-term">state sum</span>, and it is a powerful technique that appears throughout mathematical physics.</p>

    <p>Each state contributes a term to the sum. The contribution depends on two things:</p>

    <div class="step-box">
      <div class="step-num">Weight from smoothing choices</div>
      <p>If a state uses <em>a</em> A-smoothings and <em>b</em> B-smoothings, its weight is <span class="key-term"><em>A</em><sup>(a−b)</sup></span>. Each A-smoothing contributes a factor of <em>A</em>, each B-smoothing a factor of <em>A</em><sup>−1</sup>. So a state with all A-smoothings has the highest positive power of <em>A</em>, and a state with all B-smoothings has the most negative power. This is how the variable <em>A</em> encodes which smoothing choices were made.</p>
    </div>

    <div class="step-box">
      <div class="step-num">Loop factor</div>
      <p>Each simple loop in the resolved diagram is "worth" a factor of <span class="key-term">d = −A² − A⁻²</span>. If there are <em>ℓ</em> loops, the loop factor is <em>d</em><sup>ℓ−1</sup>. (Why <em>ℓ</em>−1 instead of <em>ℓ</em>? The first loop is "free" — it comes from the normalization convention that the unknot, a single circle, has bracket equal to 1 rather than <em>d</em>.) The value of <em>d</em> is not arbitrary — it is the unique value that makes the bracket invariant under certain diagram rearrangements called Reidemeister moves.</p>
    </div>

    <div class="formula-box">
      <span class="label">Kauffman Bracket</span>
      ⟨K⟩ &nbsp;=&nbsp; <span style="font-size:1.5em">Σ</span><sub style="font-size:0.7em">states s</sub> &nbsp;
      <span class="var-a">A</span><sup>(#A − #B)</sup> · (−<span class="var-a">A</span><sup>2</sup> − <span class="var-a">A</span><sup>−2</sup>)<sup>(loops−1)</sup>
    </div>

    <p>Because the variable <em>A</em> can have both positive and negative exponents (like <em>A</em><sup>−7</sup>), the result is a <span class="key-term">Laurent polynomial</span>. A regular polynomial has only non-negative powers (like 3<em>x</em>² + <em>x</em> + 5). A Laurent polynomial extends this to include negative powers too (like <em>A</em><sup>−7</sup> + <em>A</em><sup>5</sup>). All the coefficients turn out to be integers, which is remarkable — despite all the intermediate computation, the final answer is always clean.</p>

    <p>The bracket is <em>almost</em> a full knot invariant on its own. It can change by a factor under one particular type of diagram rearrangement (adding or removing a twist). To correct for this, we account for the <span class="key-term">writhe</span> — each crossing has a sign (+1 or −1, determined by the orientation of the strands), and the writhe is their sum. Dividing out the writhe-dependent factor gives the <span class="key-term">Jones polynomial</span> (or rather, Kauffman's version of it in the variable <em>A</em>):</p>

    <div class="formula-box">
      <span class="label">Jones polynomial (Kauffman's f-polynomial)</span>
      f(K) &nbsp;=&nbsp; (−<span class="var-a">A</span><sup>3</sup>)<sup>−w</sup> · ⟨K⟩
      <br><span style="font-size:0.85rem;color:var(--text-dim);">where w = writhe = sum of crossing signs</span>
    </div>

    <p>This <em>f</em>-polynomial is a true knot invariant: it does not depend on how you draw the diagram at all. It only depends on the knot itself. The Jones polynomial was originally discovered by Vaughan Jones in 1984 through a completely different route (via operator algebras in quantum mechanics); Kauffman's bracket gives a beautifully elementary way to compute it using nothing more than counting loops and doing polynomial arithmetic.</p>
  </div>

  <!-- ====== SECTION 7 ====== -->
  <div class="prose" id="sec-code">
    <h2><span class="num">7.</span> What the C code does</h2>

    <p>The C89 program implements this entire computation from scratch, with zero dependencies — just pure arithmetic and loop-counting. Here is what each part handles:</p>

    <div class="step-box">
      <div class="step-num">Laurent polynomials</div>
      <p>The code defines a <code>Poly</code> type that stores an array of integer coefficients and a lowest exponent. For instance, the polynomial <em>A</em><sup>−3</sup> + 2<em>A</em><sup>5</sup> would be stored as coefficients [1, 0, 0, 0, 0, 0, 0, 0, 2] starting at exponent −3. Addition and multiplication follow the standard rules of polynomial algebra — the same rules you learned in school, just extended to handle negative exponents. This data structure is the workhorse: all the bookkeeping of "collect like terms in <em>A</em>" is handled here.</p>
    </div>

    <div class="step-box">
      <div class="step-num">Knot diagrams</div>
      <p>Each knot is stored as an array of crossings in PD notation — exactly the arc-label lists described in section 3. The trefoil, figure-eight, and Hopf link are hard-coded from the standard Knot Atlas database. Each crossing also stores its sign (+1 or −1) for computing the writhe.</p>
    </div>

    <div class="step-box">
      <div class="step-num">Loop counting</div>
      <p>This is the topological heart of the computation. For a given state (a specific smoothing choice at every crossing), the code builds a <em>pairing table</em>: at each crossing, it records which arc gets connected to which. Then it traces through these connections — start at any arc, follow the pairing to a partner arc, jump to that arc's other crossing, follow the pairing there, and so on, until you return to where you started. That is one loop. Repeat for any unvisited arcs to find all the loops. The result is just a count: how many independent closed loops did this state produce?</p>
    </div>

    <div class="step-box">
      <div class="step-num">State sum</div>
      <p>The main computation: loop over all 2<sup>n</sup> states (using a simple integer counter where each bit represents A=0 or B=1 at that crossing). For each state, compute the weight <em>A</em><sup>(#A−#B)</sup>, count the loops, raise <em>d</em> to the appropriate power, multiply them into a polynomial term, and add it to the running total. When done, the accumulated sum is the Kauffman bracket ⟨K⟩.</p>
    </div>

    <div class="step-box">
      <div class="step-num">Verification</div>
      <p>The program checks its computed results against known values from the mathematical literature. The trefoil's bracket matches Kauffman's published result. The figure-eight's bracket is <em>palindromic</em> (its coefficients read the same forwards and backwards) — this reflects the remarkable fact that the figure-eight knot is <em>amphichiral</em>: it is equivalent to its own mirror image, the only knot with 4 or fewer crossings that has this property. The Hopf link bracket is correct. And crucially, the trefoil and figure-eight have <em>different</em> brackets, confirming that the invariant successfully distinguishes them. All 9 tests pass.</p>
    </div>

    <p class="dim">The interactive tool below is a direct JavaScript port of this C code — the same polynomial arithmetic, the same loop-counting algorithm, the same PD data. The results match exactly.</p>
  </div>

  <hr class="sep">

  <!-- ====== SECTION 8: INTERACTIVE TOOL ====== -->
  <div id="sec-tool">
    <div class="tool-header">
      <h2>Interactive Explorer</h2>
      <div class="subtitle">Choose a knot, toggle smoothings, watch the bracket assemble</div>
    </div>

    <div class="knot-selector">
      <button class="knot-btn active" data-knot="trefoil">Trefoil 3₁</button>
      <button class="knot-btn" data-knot="figure-eight">Figure-Eight 4₁</button>
      <button class="knot-btn" data-knot="hopf">Hopf Link</button>
    </div>

    <div class="knot-desc" id="knotDesc">The simplest non-trivial knot: 3 crossings, all positive. Writhe = +3.</div>

    <div class="instructions">
      Click each crossing to toggle <kbd>A</kbd> ↔ <kbd>B</kbd> smoothing. Click a row in the state table to jump to that state.
    </div>

    <div class="main-grid">
      <div class="panel">
        <div class="panel-title">Crossings — click to toggle smoothing</div>
        <div class="crossing-diagram" id="crossingDiagram"></div>
        <div style="margin-top:1.25rem;">
          <div class="panel-title">Resulting loops for this state</div>
          <div class="loop-canvas-wrap">
            <canvas id="loopCanvas" width="360" height="220"></canvas>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">All 2<sup style="font-size:0.5rem">n</sup> states — contributions to ⟨K⟩</div>
        <div class="state-table-wrap">
          <table class="state-table" id="stateTable">
            <thead><tr>
              <th>#</th>
              <th>Smoothings</th>
              <th>Loops</th>
              <th>Weight</th>
              <th>Contribution</th>
            </tr></thead>
            <tbody id="stateBody"></tbody>
          </table>
        </div>
      </div>

      <div class="panel result-panel">
        <div class="panel-title">Results</div>

        <div class="accum-controls">
          <button class="accum-btn" id="btnReset" title="Reset to state 0">⟲ Reset</button>
          <button class="accum-btn" id="btnPrev" title="Previous state">◂ Prev</button>
          <button class="accum-btn" id="btnNext" title="Next state">Next ▸</button>
          <button class="accum-btn" id="btnPlay" title="Auto-play through states">▶ Play</button>
          <span class="accum-label" id="accumLabel">State 0 / 7</span>
        </div>
        <div class="running-sum" id="runningSum"></div>

        <div style="margin-top:0.75rem;border-top:1px solid var(--border);padding-top:0.75rem;">
          <div style="font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.1em;margin-bottom:0.4rem;text-align:center;">Full Kauffman Bracket ⟨K⟩ (sum of all states)</div>
          <div class="polynomial-display" id="bracketResult"></div>
        </div>

        <div style="margin-top:0.5rem;border-top:1px solid var(--border);padding-top:0.75rem;">
          <div style="font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.1em;margin-bottom:0.4rem;text-align:center;">Jones f-polynomial = (−A³)<sup style="font-size:0.5rem">−w</sup>⟨K⟩</div>
          <div class="polynomial-display" id="jonesResult" style="font-size:1.1rem;"></div>
        </div>

        <div class="info-row" style="margin-top:0.75rem;">
          <span><span class="dot dot-a"></span> A-smoothing</span>
          <span><span class="dot dot-b"></span> B-smoothing</span>
          <span><span class="dot dot-loop"></span> loop count</span>
          <span><span class="dot dot-poly"></span> bracket</span>
        </div>
      </div>
    </div>
  </div>

</div>

<script>
/* ============================================================
 * POLYNOMIAL ARITHMETIC
 * ============================================================ */
function Poly(c, lo) { this.c = c ? c.slice() : []; this.lo = lo || 0; }
Poly.zero = function() { return new Poly([], 0); };
Poly.mono = function(coeff, exp) {
  if (coeff === 0) return Poly.zero();
  return new Poly([coeff], exp);
};
Poly.prototype.trim = function() {
  var a = 0, b = this.c.length - 1;
  while (a <= b && this.c[a] === 0) a++;
  if (a > b) { this.c = []; this.lo = 0; return this; }
  while (b > a && this.c[b] === 0) b--;
  this.c = this.c.slice(a, b + 1);
  this.lo += a;
  return this;
};
function polyAdd(a, b) {
  if (!a.c.length) return new Poly(b.c, b.lo);
  if (!b.c.length) return new Poly(a.c, a.lo);
  var lo = Math.min(a.lo, b.lo);
  var hi = Math.max(a.lo+a.c.length-1, b.lo+b.c.length-1);
  var c = new Array(hi-lo+1); var i;
  for (i=0;i<c.length;i++) c[i]=0;
  for (i=0;i<a.c.length;i++) c[a.lo+i-lo]+=a.c[i];
  for (i=0;i<b.c.length;i++) c[b.lo+i-lo]+=b.c[i];
  return new Poly(c,lo).trim();
}
function polyMul(a, b) {
  if (!a.c.length||!b.c.length) return Poly.zero();
  var len=a.c.length+b.c.length-1;
  var c=new Array(len); var i,j;
  for(i=0;i<len;i++) c[i]=0;
  for(i=0;i<a.c.length;i++) for(j=0;j<b.c.length;j++) c[i+j]+=a.c[i]*b.c[j];
  return new Poly(c,a.lo+b.lo).trim();
}
function polyEq(a,b) {
  if(a.c.length!==b.c.length) return false;
  if(!a.c.length) return true;
  if(a.lo!==b.lo) return false;
  for(var i=0;i<a.c.length;i++) if(a.c[i]!==b.c[i]) return false;
  return true;
}
function polyToHTML(p) {
  if (!p.c.length) return '<span class="coeff-pos">0</span>';
  var parts = [];
  for (var i=0;i<p.c.length;i++) {
    if (p.c[i]===0) continue;
    var e=p.lo+i, coeff=p.c[i], s='';
    if (parts.length>0) s += coeff>0 ? ' + ' : ' − ';
    else if (coeff<0) s += '−';
    var ac=Math.abs(coeff);
    var cls = coeff>0 ? 'coeff-pos' : 'coeff-neg';
    if (parts.length>0) cls = coeff>0?'coeff-pos':'coeff-neg';
    if (ac!==1||e===0) s+=ac;
    if (e===1) s+='<span class="var-a">A</span>';
    else if (e===-1) s+='<span class="var-a">A</span><span class="sup">−1</span>';
    else if (e!==0) s+='<span class="var-a">A</span><span class="sup">'+e+'</span>';
    parts.push('<span class="'+cls+'">'+s+'</span>');
  }
  return parts.join('');
}

/* ============================================================
 * KNOT DEFINITIONS
 * ============================================================ */
var KNOTS = {
  trefoil: {
    name:'Right-handed Trefoil 3₁', n:3, numArcs:6,
    desc:'The simplest non-trivial knot: 3 crossings, all positive. Writhe = +3.',
    crossings:[
      {arcs:[0,4,1,3],sign:1},{arcs:[2,0,3,5],sign:1},{arcs:[4,2,5,1],sign:1}
    ]
  },
  'figure-eight': {
    name:'Figure-Eight 4₁', n:4, numArcs:8,
    desc:'The simplest amphichiral knot (equivalent to its mirror image): 4 crossings, writhe = 0. Its bracket is palindromic.',
    crossings:[
      {arcs:[3,1,4,0],sign:1},{arcs:[7,5,0,4],sign:1},
      {arcs:[5,2,6,3],sign:-1},{arcs:[1,6,2,7],sign:-1}
    ]
  },
  hopf: {
    name:'Hopf Link', n:2, numArcs:4,
    desc:'The simplest non-trivial link: two circles linked once. 2 crossings, writhe = +2.',
    crossings:[
      {arcs:[3,0,2,1],sign:1},{arcs:[1,2,0,3],sign:1}
    ]
  }
};

/* ============================================================
 * LOOP COUNTING
 * ============================================================ */
function countLoops(knot, state) {
  var n=knot.n, na=knot.numArcs;
  var appX=[],appP=[],appN=[],pair=[],visited=[];
  var i,j;
  for(i=0;i<na;i++){appX[i]=[0,0];appP[i]=[0,0];appN[i]=0;}
  for(i=0;i<n;i++) for(j=0;j<4;j++){
    var arc=knot.crossings[i].arcs[j];
    if(appN[arc]<2){appX[arc][appN[arc]]=i;appP[arc][appN[arc]]=j;}
    appN[arc]++;
  }
  for(i=0;i<n;i++){
    pair[i]=[0,0,0,0];
    if((state>>i)&1){pair[i][0]=1;pair[i][1]=0;pair[i][2]=3;pair[i][3]=2;}
    else{pair[i][0]=3;pair[i][3]=0;pair[i][1]=2;pair[i][2]=1;}
  }
  for(i=0;i<na;i++) visited[i]=false;
  var loops=0, loopAssign=[];
  for(i=0;i<na;i++) loopAssign[i]=-1;
  for(i=0;i<na;i++){
    if(visited[i]) continue;
    var curArc=i,curSide=0;
    while(!visited[curArc]){
      visited[curArc]=true; loopAssign[curArc]=loops;
      var cx=appX[curArc][curSide],pos=appP[curArc][curSide];
      var pp=pair[cx][pos],pa=knot.crossings[cx].arcs[pp];
      var os=(appX[pa][0]===cx&&appP[pa][0]===pp)?1:0;
      curArc=pa; curSide=os;
    }
    loops++;
  }
  return {loops:loops,loopAssign:loopAssign};
}

/* ============================================================
 * BRACKET COMPUTATION
 * ============================================================ */
var D_POLY=polyAdd(Poly.mono(-1,2),Poly.mono(-1,-2));

function kauffmanBracket(knot){
  var result=Poly.zero(), n=knot.n, ns=1<<n, states=[];
  for(var s=0;s<ns;s++){
    var ac=0,bc=0;
    for(var i=0;i<n;i++){if((s>>i)&1)bc++;else ac++;}
    var info=countLoops(knot,s), loops=info.loops;
    var term=Poly.mono(1,ac-bc), dp=Poly.mono(1,0);
    for(var j=0;j<loops-1;j++) dp=polyMul(dp,D_POLY);
    var contrib=polyMul(term,dp);
    result=polyAdd(result,contrib);
    states.push({index:s,aCount:ac,bCount:bc,loops:loops,
      loopAssign:info.loopAssign,weightExp:ac-bc,contribution:contrib});
  }
  return {bracket:result,states:states};
}

function computeWrithe(k){var w=0;for(var i=0;i<k.n;i++)w+=k.crossings[i].sign;return w;}

function jonesFromBracket(bracket,knot){
  var w=computeWrithe(knot);
  return polyMul(Poly.mono(w%2===0?1:-1,-3*w),bracket);
}

/* ============================================================
 * UI STATE
 * ============================================================ */
var currentKnot='trefoil';
var smoothings=[];
var accumStep=0;
var playInterval=null;
var cachedResult=null;

function currentState(){var s=0;for(var i=0;i<smoothings.length;i++)if(smoothings[i])s|=(1<<i);return s;}

/* ============================================================
 * DRAWING HELPERS
 * ============================================================ */
var COL_A='#5b9bd5', COL_B='#d4845a';

function drawCrossing(canvas,index,isB){
  var ctx=canvas.getContext('2d'),w=canvas.width,h=canvas.height;
  var cx=w/2,cy=h/2,r=Math.min(w,h)*0.35;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle=isB?'rgba(212,132,90,0.06)':'rgba(91,155,213,0.06)';
  ctx.beginPath();ctx.arc(cx,cy,r+8,0,Math.PI*2);ctx.fill();
  ctx.lineWidth=2.5;ctx.lineCap='round';
  if(!isB){
    ctx.strokeStyle=COL_A;
    ctx.beginPath();ctx.moveTo(cx-r,cy+r*0.5);ctx.quadraticCurveTo(cx,cy-r*0.3,cx+r,cy-r*0.5);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx-r,cy-r*0.5);ctx.quadraticCurveTo(cx,cy+r*0.3,cx+r,cy+r*0.5);ctx.stroke();
  } else {
    ctx.strokeStyle=COL_B;
    ctx.beginPath();ctx.moveTo(cx-r,cy+r*0.5);ctx.quadraticCurveTo(cx-r*0.3,cy,cx-r,cy-r*0.5);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+r,cy-r*0.5);ctx.quadraticCurveTo(cx+r*0.3,cy,cx+r,cy+r*0.5);ctx.stroke();
  }
  ctx.strokeStyle='rgba(107,115,148,0.2)';ctx.lineWidth=1;ctx.setLineDash([3,3]);
  ctx.beginPath();ctx.moveTo(cx-r,cy-r*0.5);ctx.lineTo(cx+r,cy+r*0.5);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx-r,cy+r*0.5);ctx.lineTo(cx+r,cy-r*0.5);ctx.stroke();
  ctx.setLineDash([]);
  ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle='rgba(107,115,148,0.5)';ctx.textAlign='center';
  var knot=KNOTS[currentKnot],arcs=knot.crossings[index].arcs;
  ctx.fillText(arcs[0],cx-r-8,cy+r*0.5+3);
  ctx.fillText(arcs[1],cx-r-8,cy-r*0.5+3);
  ctx.fillText(arcs[2],cx+r+8,cy-r*0.5+3);
  ctx.fillText(arcs[3],cx+r+8,cy+r*0.5+3);
}

function drawLoops(knot,state){
  var canvas=document.getElementById('loopCanvas'),ctx=canvas.getContext('2d');
  var w=canvas.width,h=canvas.height;
  ctx.clearRect(0,0,w,h);
  var info=countLoops(knot,state),loops=info.loops,la=info.loopAssign;
  var colors=['#7bc77b','#5b9bd5','#d4845a','#c4a0e8','#f0d060','#e06070','#60c0c0','#d070d0'];
  var spacing=Math.min(80,(w-40)/loops);
  var startX=w/2-(loops-1)*spacing/2;
  for(var l=0;l<loops;l++){
    var cx=startX+l*spacing,cy=h/2,r=Math.min(30,spacing*0.4);
    var col=colors[l%colors.length];
    var g=ctx.createRadialGradient(cx,cy,r*0.5,cx,cy,r+10);
    g.addColorStop(0,col+'18');g.addColorStop(1,col+'00');
    ctx.fillStyle=g;ctx.beginPath();ctx.arc(cx,cy,r+6,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.strokeStyle=col;ctx.lineWidth=2.5;ctx.stroke();
    var arcsInLoop=[];
    for(var a=0;a<knot.numArcs;a++) if(la[a]===l) arcsInLoop.push(a);
    ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle=col;ctx.textAlign='center';
    ctx.fillText('loop '+(l+1),cx,cy+r+16);
    ctx.font='8px "JetBrains Mono",monospace';ctx.fillStyle='rgba(107,115,148,0.6)';
    ctx.fillText('arcs: {'+arcsInLoop.join(',')+'}',cx,cy+r+28);
  }
  ctx.font='11px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';ctx.textAlign='center';
  ctx.fillText(loops+' loop'+(loops!==1?'s':'')+' \u00b7 d^'+(loops-1)+' factor',w/2,18);
}

/* ============================================================
 * EXPLANATORY FIGURES
 * ============================================================ */
function drawFigKnots(){
  var c=document.getElementById('figKnots');
  if(!c) return;
  var ctx=c.getContext('2d'),w=c.width,h=c.height;
  ctx.clearRect(0,0,w,h);
  ctx.lineWidth=2.5;ctx.lineCap='round';

  /* Unknot */
  ctx.strokeStyle='#6b7394';
  ctx.beginPath();ctx.arc(110,h/2,40,0,Math.PI*2);ctx.stroke();
  ctx.font='12px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';ctx.textAlign='center';
  ctx.fillText('unknot',110,h/2+60);

  /* Trefoil (schematic) */
  var tx=340,ty=h/2;
  ctx.strokeStyle='#5b9bd5';
  ctx.beginPath();
  /* Draw a trefoil-like shape using bezier curves */
  var pts=[
    [tx,ty-45],[tx+40,ty-15],[tx+30,ty+30],[tx,ty+15],
    [tx-30,ty+30],[tx-40,ty-15],[tx,ty-45]
  ];
  ctx.moveTo(pts[0][0],pts[0][1]);
  for(var i=0;i<pts.length-1;i++){
    var nx=(pts[i][0]+pts[i+1][0])/2, ny=(pts[i][1]+pts[i+1][1])/2;
    ctx.quadraticCurveTo(pts[i][0],pts[i][1],nx,ny);
  }
  ctx.quadraticCurveTo(pts[pts.length-1][0],pts[pts.length-1][1],pts[0][0],pts[0][1]);
  ctx.stroke();
  /* Crossing indicators */
  ctx.fillStyle='rgba(91,155,213,0.3)';
  ctx.beginPath();ctx.arc(tx+10,ty-10,4,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(tx-15,ty+12,4,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(tx+15,ty+15,4,0,Math.PI*2);ctx.fill();
  ctx.font='12px "JetBrains Mono",monospace';ctx.fillStyle='#5b9bd5';ctx.textAlign='center';
  ctx.fillText('trefoil',tx,ty+60);
  ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';
  ctx.fillText('3 crossings',tx,ty+74);

  /* Hopf link */
  var hx=570,hy=h/2;
  ctx.strokeStyle='#c4a0e8';
  ctx.beginPath();ctx.ellipse(hx-18,hy,28,38,0,0,Math.PI*2);ctx.stroke();
  ctx.strokeStyle='#d4845a';
  ctx.beginPath();ctx.ellipse(hx+18,hy,28,38,0,0,Math.PI*2);ctx.stroke();
  ctx.fillStyle='rgba(196,160,232,0.3)';
  ctx.beginPath();ctx.arc(hx,hy-18,4,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(hx,hy+18,4,0,Math.PI*2);ctx.fill();
  ctx.font='12px "JetBrains Mono",monospace';ctx.fillStyle='#c4a0e8';ctx.textAlign='center';
  ctx.fillText('Hopf link',hx,hy+60);
  ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';
  ctx.fillText('2 crossings',hx,hy+74);
}

function drawFigCrossing(){
  var c=document.getElementById('figCrossing');
  if(!c) return;
  var ctx=c.getContext('2d'),w=c.width,h=c.height;
  ctx.clearRect(0,0,w,h);
  var cx=w/2,cy=h/2,r=55;

  /* Over-strand (continuous) */
  ctx.strokeStyle='#5b9bd5';ctx.lineWidth=3;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(cx-r,cy-r*0.6);ctx.lineTo(cx+r,cy+r*0.6);ctx.stroke();

  /* Under-strand (with gap) */
  ctx.strokeStyle='#d4845a';ctx.lineWidth=3;
  var gapSize=12;
  ctx.beginPath();ctx.moveTo(cx-r,cy+r*0.6);ctx.lineTo(cx-gapSize,cy+gapSize*0.02);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx+gapSize,cy-gapSize*0.02);ctx.lineTo(cx+r,cy-r*0.6);ctx.stroke();

  /* Labels */
  ctx.font='bold 14px "JetBrains Mono",monospace';ctx.textAlign='center';
  ctx.fillStyle='#d4845a';
  ctx.fillText('a',cx-r-16,cy+r*0.6+5);
  ctx.fillText('c',cx+r+16,cy-r*0.6+5);
  ctx.fillStyle='#5b9bd5';
  ctx.fillText('b',cx-r-16,cy-r*0.6+5);
  ctx.fillText('d',cx+r+16,cy+r*0.6+5);

  /* Position numbers */
  ctx.font='10px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';
  ctx.fillText('(0)',cx-r-16,cy+r*0.6+19);
  ctx.fillText('(1)',cx-r-16,cy-r*0.6+19);
  ctx.fillText('(2)',cx+r+16,cy-r*0.6+19);
  ctx.fillText('(3)',cx+r+16,cy+r*0.6+19);

  /* Center dot */
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.beginPath();ctx.arc(cx,cy,3,0,Math.PI*2);ctx.fill();

  /* Annotations */
  ctx.font='11px "Crimson Pro",serif';ctx.fillStyle='#d4845a';
  ctx.textAlign='left';ctx.fillText('under-strand',cx+r+30,cy-10);
  ctx.fillStyle='#5b9bd5';
  ctx.fillText('over-strand',cx+r+30,cy+10);
}

function drawFigSmoothing(){
  var c=document.getElementById('figSmoothing');
  if(!c) return;
  var ctx=c.getContext('2d'),w=c.width,h=c.height;
  ctx.clearRect(0,0,w,h);
  var sy=h/2, r=35;

  /* Original crossing */
  var ox=100;
  ctx.strokeStyle='#5b9bd5';ctx.lineWidth=2.5;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(ox-r,sy-r*0.6);ctx.lineTo(ox+r,sy+r*0.6);ctx.stroke();
  ctx.strokeStyle='#d4845a';ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(ox-r,sy+r*0.6);ctx.lineTo(ox-8,sy+2);ctx.stroke();
  ctx.beginPath();ctx.moveTo(ox+8,sy-2);ctx.lineTo(ox+r,sy-r*0.6);ctx.stroke();
  ctx.font='10px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';ctx.textAlign='center';
  ctx.fillText('original',ox,sy+r+20);

  /* Arrow */
  ctx.strokeStyle='#6b7394';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(170,sy);ctx.lineTo(190,sy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(187,sy-3);ctx.lineTo(190,sy);ctx.lineTo(187,sy+3);ctx.stroke();

  /* A-smoothing */
  var ax=280;
  ctx.strokeStyle=COL_A;ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(ax-r,sy+r*0.5);ctx.quadraticCurveTo(ax,sy-r*0.3,ax+r,sy-r*0.5);ctx.stroke();
  ctx.beginPath();ctx.moveTo(ax-r,sy-r*0.5);ctx.quadraticCurveTo(ax,sy+r*0.3,ax+r,sy+r*0.5);ctx.stroke();
  ctx.font='11px "JetBrains Mono",monospace';ctx.fillStyle=COL_A;ctx.textAlign='center';
  ctx.fillText('A-smoothing',ax,sy+r+20);
  ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';
  ctx.fillText('pairs: (0,3) (1,2)',ax,sy+r+34);

  /* Arrow */
  ctx.strokeStyle='#6b7394';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(350,sy);ctx.lineTo(370,sy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(367,sy-3);ctx.lineTo(370,sy);ctx.lineTo(367,sy+3);ctx.stroke();

  /* B-smoothing */
  var bx=460;
  ctx.strokeStyle=COL_B;ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(bx-r,bx-r);
  ctx.beginPath();ctx.moveTo(bx-r,sy+r*0.5);ctx.quadraticCurveTo(bx-r*0.3,sy,bx-r,sy-r*0.5);ctx.stroke();
  ctx.beginPath();ctx.moveTo(bx+r,sy-r*0.5);ctx.quadraticCurveTo(bx+r*0.3,sy,bx+r,sy+r*0.5);ctx.stroke();
  ctx.font='11px "JetBrains Mono",monospace';ctx.fillStyle=COL_B;ctx.textAlign='center';
  ctx.fillText('B-smoothing',bx,sy+r+20);
  ctx.font='9px "JetBrains Mono",monospace';ctx.fillStyle='#6b7394';
  ctx.fillText('pairs: (0,1) (2,3)',bx,sy+r+34);
}

/* ============================================================
 * BUILD UI
 * ============================================================ */
function buildCrossingDiagram(){
  var knot=KNOTS[currentKnot],container=document.getElementById('crossingDiagram');
  container.innerHTML='';
  for(var i=0;i<knot.n;i++){
    var box=document.createElement('div');box.className='crossing-box';
    var cvs=document.createElement('canvas');cvs.width=100;cvs.height=100;box.appendChild(cvs);
    var label=document.createElement('div');label.className='crossing-label';
    label.textContent='X'+i+' ['+knot.crossings[i].arcs.join(',')+']';box.appendChild(label);
    var stype=document.createElement('div');stype.className='smoothing-type type-a';
    stype.textContent='A-smoothing';stype.id='stype-'+i;box.appendChild(stype);
    box.addEventListener('click',(function(idx){return function(){smoothings[idx]=smoothings[idx]?0:1;updateAll();};})(i));
    container.appendChild(box);
  }
}

function buildStateTable(){
  var knot=KNOTS[currentKnot];
  cachedResult=kauffmanBracket(knot);
  var states=cachedResult.states;
  var tbody=document.getElementById('stateBody');
  tbody.innerHTML='';
  var cs=currentState();
  for(var s=0;s<states.length;s++){
    var st=states[s],tr=document.createElement('tr');
    if(st.index===cs) tr.className='active-state';
    var td0=document.createElement('td');td0.textContent='#'+st.index;td0.style.color='var(--text-dim)';tr.appendChild(td0);
    var td1=document.createElement('td');
    var bits=document.createElement('span');bits.className='state-bits';
    for(var b=0;b<knot.n;b++){
      var bit=document.createElement('span');
      bit.className='bit '+(((st.index>>b)&1)?'bit-b':'bit-a');
      bit.textContent=((st.index>>b)&1)?'B':'A';bits.appendChild(bit);
    }
    td1.appendChild(bits);tr.appendChild(td1);
    var td2=document.createElement('td');
    var badge=document.createElement('span');badge.className='loops-badge';badge.textContent=st.loops;
    td2.appendChild(badge);tr.appendChild(td2);
    var td3=document.createElement('td');
    td3.innerHTML='A<sup style="font-size:0.6rem">'+st.weightExp+'</sup>\u00b7d<sup style="font-size:0.6rem">'+(st.loops-1)+'</sup>';
    tr.appendChild(td3);
    var td4=document.createElement('td');td4.innerHTML=polyToHTML(st.contribution);td4.style.fontSize='0.68rem';
    tr.appendChild(td4);
    tr.addEventListener('click',(function(idx,nn){return function(){
      for(var b=0;b<nn;b++) smoothings[b]=(idx>>b)&1;
      accumStep=idx;updateAll();
    };})(st.index,knot.n));
    tbody.appendChild(tr);
  }
}

function updateAll(){
  var knot=KNOTS[currentKnot];
  var boxes=document.querySelectorAll('.crossing-box');
  for(var i=0;i<boxes.length;i++){
    var cvs=boxes[i].querySelector('canvas');
    drawCrossing(cvs,i,!!smoothings[i]);
    var stype=document.getElementById('stype-'+i);
    if(smoothings[i]){stype.className='smoothing-type type-b';stype.textContent='B-smoothing';}
    else{stype.className='smoothing-type type-a';stype.textContent='A-smoothing';}
  }
  drawLoops(knot,currentState());
  var rows=document.querySelectorAll('#stateBody tr'),cs=currentState();
  for(var r=0;r<rows.length;r++) rows[r].className=(r===cs)?'active-state':'';
  updateAccumDisplay();
}

function updateAccumDisplay(){
  var knot=KNOTS[currentKnot];
  var ns=1<<knot.n;
  var label=document.getElementById('accumLabel');
  label.textContent='State '+accumStep+' / '+(ns-1);
  /* Running sum up to accumStep */
  var running=Poly.zero();
  for(var i=0;i<=accumStep&&i<cachedResult.states.length;i++){
    running=polyAdd(running,cachedResult.states[i].contribution);
  }
  var el=document.getElementById('runningSum');
  if(accumStep>=ns-1){
    el.innerHTML='<span style="color:var(--text-dim);font-size:0.8rem;">Sum complete →</span> '+polyToHTML(running);
  } else {
    el.innerHTML='<span style="color:var(--text-dim);font-size:0.8rem;">Running sum (states 0–'+accumStep+'):</span> '+polyToHTML(running);
  }
}

function renderResult(){
  var knot=KNOTS[currentKnot];
  cachedResult=kauffmanBracket(knot);
  document.getElementById('bracketResult').innerHTML='⟨K⟩ = '+polyToHTML(cachedResult.bracket);
  var jones=jonesFromBracket(cachedResult.bracket,knot);
  var w=computeWrithe(knot);
  document.getElementById('jonesResult').innerHTML=
    '<span style="color:var(--text-dim);font-size:0.7rem;">writhe w = '+w+' → </span>f(K) = '+polyToHTML(jones);
}

function selectKnot(name){
  if(playInterval){clearInterval(playInterval);playInterval=null;document.getElementById('btnPlay').classList.remove('active-play');document.getElementById('btnPlay').textContent='▶ Play';}
  currentKnot=name;
  var knot=KNOTS[name];
  smoothings=[];for(var i=0;i<knot.n;i++) smoothings.push(0);
  accumStep=0;
  document.querySelectorAll('.knot-btn').forEach(function(b){b.classList.toggle('active',b.dataset.knot===name);});
  document.getElementById('knotDesc').textContent=knot.desc;
  buildCrossingDiagram();
  buildStateTable();
  renderResult();
  updateAll();
}

/* Accumulation controls */
document.getElementById('btnReset').addEventListener('click',function(){
  accumStep=0;
  for(var i=0;i<smoothings.length;i++) smoothings[i]=0;
  updateAll();
});
document.getElementById('btnPrev').addEventListener('click',function(){
  if(accumStep>0){
    accumStep--;
    var knot=KNOTS[currentKnot];
    for(var b=0;b<knot.n;b++) smoothings[b]=(accumStep>>b)&1;
    updateAll();
  }
});
document.getElementById('btnNext').addEventListener('click',function(){
  var ns=1<<KNOTS[currentKnot].n;
  if(accumStep<ns-1){
    accumStep++;
    var knot=KNOTS[currentKnot];
    for(var b=0;b<knot.n;b++) smoothings[b]=(accumStep>>b)&1;
    updateAll();
  }
});
document.getElementById('btnPlay').addEventListener('click',function(){
  var btn=this;
  if(playInterval){
    clearInterval(playInterval);playInterval=null;
    btn.classList.remove('active-play');btn.textContent='▶ Play';return;
  }
  var ns=1<<KNOTS[currentKnot].n;
  accumStep=0;
  for(var i=0;i<smoothings.length;i++) smoothings[i]=0;
  updateAll();
  btn.classList.add('active-play');btn.textContent='⏸ Pause';
  playInterval=setInterval(function(){
    if(accumStep>=ns-1){clearInterval(playInterval);playInterval=null;btn.classList.remove('active-play');btn.textContent='▶ Play';return;}
    accumStep++;
    var knot=KNOTS[currentKnot];
    for(var b=0;b<knot.n;b++) smoothings[b]=(accumStep>>b)&1;
    updateAll();
  },800);
});

/* Knot buttons */
document.querySelectorAll('.knot-btn').forEach(function(btn){
  btn.addEventListener('click',function(){selectKnot(this.dataset.knot);});
});

/* Init */
drawFigKnots();
drawFigCrossing();
drawFigSmoothing();
selectKnot('trefoil');
</script>
</body>
</html>
